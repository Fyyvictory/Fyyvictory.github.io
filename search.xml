<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[android开发艺术探索笔记]]></title>
    <url>%2F2019%2F07%2F12%2Fandroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[taskaffinity,任务相关性，这个参数标识了一个activity所需要的任务栈的名字，默认情况下，所有activity所属的任务栈的名字为应用的包名。如果为每一个activity单独制定taskaffinity属性，这个属性不能和包名一直，否则相当于没有指定。taskaffinity属性主要是和singleTask启动模式或allowTaskReparenting属性配对使用，在其他情况下没有意义。另外，任务栈分为前台任务栈和后台任务栈，后台任务栈中的activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。 当taskAffinity和singleTask启动模式配对使用的时候，他是具有该模式的activity的目前任务栈的名字，待启动的activity会运行在名字和taskAffinity相同的任务栈中。 当taskAffinity和allowTaskReparenting结合时，eg： 有两个应用a,b，b的一个activity名为x,x的allowTaskReparenting属性为true的话，那么当应用a启动应用x的时候，然后按home键回到桌面，然后再单击b的桌面图标，这时启动的并不是b的主activity，而是重新显示了已经被应用A启动的activity x，或者说x从a的任务栈中转移到了b的任务栈中 IPC，进程间通信，或者称为跨进程通信，指的是两个进程间进行数据交换的过程。Android中最有特色的进程间通信方式就是Binder。其次，通过socket也可以实现任意两个终端之间的通信。 一个应用内开启多进程的方式是设定Androidmanifest.xml中的process属性，其中process属性的值以”:“开头的属于当前应用的私有进程，其它应用的组件不可以和它跑在同一个进程中，而process的值不以”:“开头的进程属于全局进程，其他应用通过shareUID方式可以和它跑在同一个进程中。 一般来说，使用多进程会造成以下几个方面的问题： 静态成员和单例模式完全失效。 线程同步机制完全失效。 sharedPreferences的可靠性下降。 Application会多次创建。 四大组件中三大组件（activity，service，receiver）都是支持在intent中传递bundle数据的，由于bundle实现了parcelable接口，所以他可以方便的在不同进程间传输 使用文件共享。文件共享也是一种不错的进程间通信方式，两个进程通过读/写同一个文件来交换数据。然而可能存在的问题是两个线程并发读写同一个文件的时候。 tips：反序列化得到的对象只是在内容上和序列化之前的对象一样，但本质上还是两个对象。 Tips2：sharePreferences底层实现上是采用XML文件来存储的键值对，本质上也属于文件的一种，但由于系统对它的读写有一定的缓存策略，即内存中会存在一份sharepreferences文件的缓存，因此，在多进程模式下，系统对它的读写变得不可靠，当面对高并发的读写访问时，sharePreferences有很大的几率会丢失数据，因此，不建议在进程间通信使用sharePreferences。 使用messenger。messenger是一种轻量级的IPC方案，她的底层实现是AIDL。在进程间通信的时候，Android 2.2以前message的object字段不支持跨进程传输，2.2以后message的object字段也仅支持系统提供的实现parcelable接口的对象才能通过它来传输，这意味着我们自定义的parcelable对象是无法通过object字段来传输的。不过我们还是可以使用bundle来传输大量的数据类型。 使用AIDL。使用messenger来进行进程间通信的方法时，messenger是以串行的方式处理客户端发来的信息，如果大量的信息同时发送到服务端，服务端仍然只能一个一个处理，如果有大量的并发请求，那么使用messenger就不太合适了。同时，messenger的作用主要是为了传递信息，很多时候可能需要跨进程调用服务端的方法，这种情形messenger就无法做到了。这种情况下的跨进程操作就可以使用AIDL来实现。 remoteCallbackList 是系统专门提供的用于删除跨进程listener的接口。CallbackList是一个泛型，支持管理任意的AIDL接口。它的工作原理是其内部有一个Map结构专门用来保存所有AIDL的回调，这个Map的key是Ibinder类型，value是Callback类型。 为了程序的健壮性，我们还需要做一件事，Binder可能会意外死亡，这往往是因为服务端进程意外停止了，这时我们需要重新连接服务。有两种方法，第一种是给Binder设置DeathRecipient监听，当Binder死亡时，我们可以收到BinderDied方法回调，在binderDied方法中我们可以重连远程服务。另一种方法是在onServiceDisconnected中重连远程服务。两者区别在于onServiceDisconnected是在客户端的UI线程中会掉的，而binderDied在客户端的Binder线程池中被回调，也就是说binderDied中不能访问UI。 使用ContentProvider。ContentProvider是Android中提供的专门用于不同应用间进行数据共享的方式。ContentProvider的底层实现同样是Binder。ContentProvider主要以表格的形式来组织数据，并且可以包含多个表。此外，ContentProvider还支持文件数据。但是需要关注多线程访问的同步问题。 MotionEvent，即手指接触屏幕之后发生的一系列的事件，常见的包括ACTION_DOWN，ACTION_UP，ACTION_MOVE，正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件。此外系统还为我们提供了两组方法：getX/getY和getRowX和getRowY。他们的区别在于前者是返回相对于当前View左上角的x和y坐标，而后者是返回的相对于手机屏幕左上角的x和y坐标。 TouchSlop是系统所能识别出的被认为是滑动的最小距离，这是一个常量，如果手指在屏幕上滑动的距离小于这个常量，那么系统就不认为该操作是滑动行为。ViewConfiguration.get(getContext()).getScaledTouchSlop()可以获取到该常量。 VelocityTracker，速度追踪。用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。其使用方式如下： 在View的onTouchEvent方法中追踪当前点击事件的速度 123VelocityTricker velocityTracker = VelocityTracker.obtain;//把MotionEvent对象传进去velocityTracker.addMovement(event); 然后采用以下方式获取当前速度。 123velocityTricker.computeCurrentVelocity(1000);int x = velocityTracker.getXVelocity();int y = velocityTracker.getYVelocity(); Ps:注意，第一，获取速度之前必须先计算速度，即在使用getXVelocity和getYVelocity这两个方法之前必须先调用computeCurrentVelocity方法。第二，这里的速度所指的是一段时间内手指所划过的像素数。第三，速度可以是负数，因为速度的方向如果是从右往左或者从下向上，速度即为负值。 最后，当不需要使用的时候，需要调用clear方法来重置并回收内存。 12velocityTracker.clear();velocityTracker.recycle(); GestureDetector,手势检测，用于辅助监测用户的单击、滑动、长按、双击等行为。使用过程如下： 123456Gesturedetector detector = new GestureDetector(this);//解决长按屏幕后无法拖动的现象detector.setIsLongpressEnable(false);//接管目标View的onTouchEvent方法，在待监听View的onTouchEvent方法中添加如下实现：boolean consume = detector.onTouchEvent(event);return consume; 做完这两步，可以有选择的实现OnGestureListener和OnDoubleTapListener中的方法。 建议：如果只是监听滑动，可以使用onTouchEvent中实现，如果要监听双击这种行为的话，使用GestureDetector会更加方便。 Scroller ，弹性滑动对象，用于实现View的弹性滑动。当使用View的scrollto/scrollby进行的滑动是一瞬间完成的，使用scroller可以实现过渡效果的滑动。使用中，Scroller需要与computeScroll方法配合使用太能共同完成这个功能。使用也是固定范式，如下： 12345678910111213141516Scroller scroller = new Scroller(context);// 缓慢滚到指定位置private void smoothScrollTo(int desX,int dexY)&#123; int scrollX = getScrollX(); int delta = desX - scrollX; scroller.startScroll(scrollX,0,delta,0,1000)； invalidate();&#125;@Overridepublic void computeScroll()&#123; if(scroller.computeScrollOffset())&#123; scrollTo(scroller.getCurrX(),scroller.getCurrY()); postInvalidate(); &#125; &#125; view 的滑动实现有三种方式： 通过view本身提供的scrollTo/scrollBy方法来实现滑动。这两个方法只能改变view内容的位置而不能改变View在布局中的位置。 使用动画，通过动画让一个view平移。主要操作View的translationX和translationY属性。需要注意的是view只能改变view视觉上的位置，但是并不能真正的改变view的位置参数。属性动画解决了这一问题，属性动画使用如下： 1ObjectAnimation.ofFloat(targetView,"translationX",0,100).setDuration(100).start(); 改变布局参数。即改变LayoutParams。通过改变LayoutParams的方式去实现View的滑动同样是一种很灵活的方式，需要根据不同的情况去做不同的处理。 点击事件的传递，请看下方伪代码： 123456789public boolean dispatchTouchEvent(MotionEvent ev)&#123; boolean consume = false; if(onInterceptTouchEvent(ev))&#123; consume = onTouchEvent(ev); &#125;else&#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这个事件如何处理还要看OnTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用，如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高。在onTouchEvent方法中，如果当前设置的有OnClickListener，那么onclick方法会被调用，由此可见，我们常用的OnClickListener优先级最低，即处于事件传递的尾端。 当一个点击事件产生后，传递过程如下：activity —&gt;window—&gt;View。正常情况下，一个事件序列只能被一个View拦截且消耗，因为一旦一个元素拦截了某次时间，那么同一个事件序列内的所有事件都会直接交给它处理，因此它的onInterceptTouchEvent不会再被调用。 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一系列的其他事件也不会再交给它来处理，并且事件将重新交由它的父元素来处理。 Viewgroup默认不拦截任何事件。 View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会调用。view的longClickable属性默认都是false。 View的enable属性不影响onTouchEvent的默认返回值，即便一个view是disable状态的，只要它的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。 通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 一个view（viewgroup除外），不可用状态下依旧会消耗掉点击事件。 setonclicklistener和setlongclicklistener会自动将view的clickable和longclickable 系统可能需要多次measure才能确定最终的测量宽高，在这种情形下，在onMeasure方法中拿到的测量宽高可能不准确，可以在onLayout方法中获取View的测量宽高或最终宽高。 在activity中获取view的宽高准确时机在于： onWindowFocusChanged。该方法的含义是：view已经初始化完毕，宽高准备好了，然而需要注意的是，当activity的窗口失去焦点和得到焦点都会调用该方法，所以，如果频繁的调用onresume和onpause，那么onWIndowForcusChanged也会频繁调用。 view.post(runnable)。通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用这个runnable的时候，view也已经初始化好了。 ViewTreeObserver。使用ViewTreeObserver的众多回调可以完成这个功能，比如OnGlobalLayoutListener这个接口，是当View树的状态发生改变或view树内部的view的可见性变化时，onGlobalLayout方法将被回调。 123456789ViewTreeObserver observer = view.getViewTreeObserver();observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener()&#123; @Override public void onGlobalLayout()&#123; view.getViewTreeObserver().removeGlobalOnLayoutListener(this); int width = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); &#125;&#125;) View.measure(int widthMeasureSpec,int heightMeasureSPec)。通过手动对view进行measure来得到view的宽高，这种方法比较复杂，需要根据view的layoutParams来分。 - match_parent。直接放弃，无法measure出具体宽高。 具体数字（dp/px）。 wrap_content，AT_MOST计算。 Layout的作用是ViewGroup用来确定子元素的位置。 自定义view须知： 让view支持wrap_content 如果有必要，让view支持padding 尽量不要在view中使用handler。因为view内部本身提供了post系列方法，完全可以替代handler的作用。 view中如果有线程或者动画，需要及时停止。参考onDetachedFromWindow。与该方法相对的是onAttachedToWindow。如果不及时处理，可能造成内存泄漏。 view带有滑动嵌套的时候，需要处理好滑动冲突。 remoteview在实际开发中，主要用于通知栏和桌面小部件的开发过程。remoteview是运行在systemServer进程中，为了跨进程更新页面，RemoteView提供一系列的set方法。 APPWidgetProvider是Android中提供的用于实现桌面小部件的类，其本质是一个广播。所以使用的时候需要在Manifest文件中声明注册。 PendingIntent支持三种待定意图：启动activity，启动service和发送广播 Drawable有很多种。 LayerDrawable。LayerDrawable对应的XML标签是 ,它表示一种层次化的Drawable集合，通过将不同的Drawable放置在不同的层上面从而达到一种叠加后的效果。 StateListDrawable对应于标签，每个Drawable都对应view的一种状态。 LevelListDrawable。对应于标签，它也表示一个Drawable集合，集合中的每个Drawable都有一个等级（level）的概念。根据不同的等级，LevelListDrawable会切换为对应的Drawable。 transitionDrawable对应于标签，用于实现Drawable之间的淡入和淡出效果。 InsertDrawable对应于标签，可以把其它Drawable内嵌到自己当中。 ScaleDrawable对应于scale标签，他可以根据自己的等级将指定的Drawable缩放到一定比例。 ClipDrawable，对应于标签，他可以根据自己当前的等级来裁剪另一个Drawable，裁剪方向可以通过android:clipOrientation和android:gravity这两个属性来共同控制。 interpolator，表示动画集合所采用的差值器，差值器影响动画的速度，该属性的默认值是加速减速差值器。 shareInterpolator，表示集合中的动画是否和集合共享同一个差值器。 自定义动画是一件既简单又复杂的事情。派生一种新的动画只需要继承Animation这个抽象类，然后重写它的initialize和applyTransformation方法。在initialize方法中做一下初始化工作，在applyTransformation中进行相应的矩阵变换即可。 activity的切换效果，主要用到overridePendingTransition(int enterAnim,int exitAnim)这个方法。overridePendingTransition这个方法必须用于startActivity或者finish的后面，否则动画效果不起作用。 fragment也可以添加切换动画，由于fragment是API11的新引入的类，因此为了兼容性，我们需要使用support-v4这个兼容包，这种情况下，可以通过fragmentTransaction中的setCustomAnimation（）方法来添加切换动画。PS：切换动画需要是View动画，之所以不适用属性动画，是因为属性动画也是API11引入的 属性动画可以对任意对象的属性进行动画，而不仅仅是View，动画默认时间间隔是300ms，默认帧率10ms/帧。其达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。属性动画是从API11才引入的。 插值器。TimeInterpolator，时间插值器，它的作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预设的有LInearInterpolator(匀速)，AccelerateDecelerateInterpolator(加速减速)和DecelerateInterpolator（减速）等。TypeEvaluator，类型估值算法，也叫估值器，它的作用是根据当前属性改变的百分比计算改变后的属性值。系统预设的有IntEvaluator，FloatEvaluator和ArgbEvaluator。插值器和估值器也可以自定义。 属性动画的监听器。属性动画提供了监听器用于监听动画的播放过程，主要有两个接口AnimatorUpdateListener和AnimatorListener。 属性动画生效的两个条件：1、对象必须提供set方法，如果没有初始值，还要提供get方法（如果这条不满足，程序直接crash）；2、对象的set方法对属性的修改必须通过某种方式反映出来，比如UI的改变之类的（如果这条不满足，动画无效果，但不会crash） 每一个window都对应一个View和一个ViewRootImpl,window和view是通过ViewRootImpl来建立联系的.windowManager提供的三个接口方法addView、updateViewLayout和removeView都是针对View的，说明View才是Window存在的实体。在实际使用中，无法直接访问window，而是通过windowManager。window的操作是IPC的过程。 view是Android中的视图的呈现方式，但是view不能单独存在，他必须依附在Window这个抽象的概念上，因此有视图的地方就有window。 普通dialog有一个特殊之处，就是必须采用activity的context，如果采用Application的context，就会报错没有应用token，而应用token一般只有activity拥有。另外，系统window比较特殊，它不需要token。 静态注册的广播在应用安装时有系统自动完成注册，具体来说是由PMS（packageManagerService）来完成整个注册过程，除广播外，其他三大组件也都是在应用安装时由PMS解析并注册的。动态注册的过程是从ContextWrapper的registerReceiver方法开始的。 广播的发送有几种类型：普通广播，有序广播和粘性广播。 ContentProvider的oncreate要先于Application的onCreate而执行。这在四大组件中是少有的现象。ContentProvider提供的增删改查四个接口操作ContentProvider的数据源。这四个方法都是通过Binder来调用的，外界无法直接访问ContentProvider，它只能通过AMS根据Uri来获取对应的ContentProvider的Binder接口IContentProvider，然后通过IContentProvider来访问ContentProvider。 一般来说ContentProvider都应该是单例的，它是否单例是由它的android:multiprocess属性来决定的。当这个属性是false时，ContentProvider是单例，当属性为true时，ContentProvider是多实例的。每个调用者的进程中都会存在一个ContentProvider对象。 Android的消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑。MessageQueue虽然名为队列，但是内部确实采用单链表的数据结构来存储消息列表。Looper中还有一个特殊的概念，就是ThreadLocal。ThreadLocal并不是线程，它的作用是可以在每个线程中存储数据。Handler创建的时候会采用当前线程的Looper来构造消息循环系统，那么Handler可以通过ThreadLocal可以获取到每个线程的Looper。当然需要注意的是 线程是默认没有Looper的，如果需要使用Handler就必须为线程创建Looper。UI线程，也就是ActivityThread被创建时会初始化Looper，这也是主线程中默认可以使用Handler的原因。 系统不允许子线程访问UI的原因在于：Android的UI控件不是线程安全的，如果在多线程中并发访问可能导致UI控件处于不可预期的状态。那么不给UI控件加锁来保证线程安全的原因，也有一些，主要缺点如下：首先加锁机制会让UI访问的逻辑变得复杂；其次，加锁会降低UI访问的效率，因为锁会阻塞线程的执行。由此对比，使用handler更加的简单高效。 ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据。 线程池的有点：1）重用线程池中的线程，避免因为线程的创建和销毁带来的性能损耗；2）能有效控制线程池的最大并发数，避免大量的线程之间因为互相抢占系统资源而导致的阻塞现象。3）对线程进行简单的管理，并提供定时执行以及制定间隔循环执行等功能。 CrashHandler来监视应用的crash信息。]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码整洁之道笔记]]></title>
    <url>%2F2019%2F06%2F19%2F%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[代码命名需要规范直接，可以一眼看出来命名的含义 即便容器就是一个list，最好也别在名称中写出容器类型名 代码命名要做有意义的区分，不要使用info，data等这样没有实际意义的文字去做区分 一个函数只做一件事；判断一个函数是否只做了一件事，就看该函数是否可以合理的切分成多个区段。 自顶向下的规则：让代码拥有自顶向下的阅读顺序，让每一个函数后面都跟着下一抽象层级的函数，这样，在查看函数列表的时候，就能循着抽象层级向下阅读了。 对于switch语句，一般用于创建多态对象，而且隐藏在某个继承关系中，在系统其它部分看不见。即一般用于工厂模式中。 别害怕长名字，长而具有描述性的名称，要比短而令人费解的名称好，长而具有描述性的名称，要比描述性的长注释好。 尽量减少函数参数，一般不宜超过三个。 依赖磁铁。其它许多类都需要导入或使用该类，例如：常量类。 避免代码重复，面向对象编程，面向组件编程其中都包含消除重复代码的思想。 函数是语言的动词，类是名词 👨‍💻‍应该负责将注释保持在可维护，有关联，精确的高度，但是更加需要注重的能力是代码尽量的明确简洁，尽量的不要依赖于注释 TODO注释标记时，完成之后需要及时清理 编写公共API的时候，尽量编写完整的javadoc，当然，也需要注意上面几条提示，保证javadoc的可维护性和精确性。 注释需要清晰完整，不要让看到的人需要联系上下文才能理解注释的 能用函数或变量时就别用注释，可以把一个相当长的表达式拆分成短小直观的多个表达式，好处在于其一，便于阅读和维护，其二，便于避免逻辑漏洞。 清理注释掉的代码，因为99%的情况下注释掉的代码不会再用到。 一个项目中应该保持一套一致的代码格式规则 函数或属性之间的垂直距离。关系密切的概念应该相互靠近。变量声明应该尽可能靠近其使用位置；实体变量应该在类的顶部声明。若某个函数调用了另一个，就应该把它们放在一起，并且调用者放在被调用者之上，这样会形成自上而下的调用顺序。概念相关的代码也应该放在一起(相关性包括相互调用，同一组函数或者执行相似操作的代码) 代码行尽可能的简短，不需要拖动滚动条就可以查看完整这一行的代码；这也意味着函数长度不要过长，不要一句代码嵌套太多函数，最好是分成多行简短的代码，这样增加代码可读性。 隐藏实现并非只是在变量之间放上一个函数层那么简单，隐藏实现关乎抽象，类并不简单的用get，set方法将变量完全暴露出来，而是暴露抽象接口，以便用户无需了解数据的实现就能操作数据本体。(即用户可以直接使用现有的实现而无需关心实现的细节) 面向对象的编程在于不改变现有的函数，而是增加新的类；面向过程的编程是不需要增加新的类，而是修改函数。两者各有使用场景； 德墨忒耳律认为，模块不应了解它所操作对象的内部情形，这意味着对象不应通过存取器暴露其内部结构。 连串调用一般被称为火车失事，通常被认为是肮脏的风格，应该避免。 混杂调用也是需要避免的函数调用方式，同一个对象调用中，应当尽量隐藏内部实现细节。 DTO(data transfer objects)；最为精练得数据结构，是一个只有公共变量，没有函数的类。这种数据结构有时被称为数据传送对象。一般在与数据库通信、或解析套接字传递的消息之类的场景中。 使用异常，而非返回码。因为异常是需要显式的处理或抛出；而如果使用返回码，调用者很容易忘记处理。 打包第三方库，即把对第三方库的调用封装，那么后续有什么修改只需要改动封装类即可，避免整个项目大量的修改。 尽量避免返回null值，返回null值，调用者就需要有各种空判断。 别传递null值， 覆盖生产代码的自动化单元测试程序组能尽可能的保持设计和架构的整洁。 整洁的测试需要遵循以下5条规则FIRST；F：快速执行；I：测试应当相互独立，某个测试不应为下一个测试的设定条件；R：可重复，测试应该在任何环境下重复通过；S：自足验证，测试应该有布尔值输出，无论通过还是失败，不应该通过查看日志来确认测试是否通过；T：测试应该及时编写。 类的名称应该描述其权责，并且类应当尽量的短小。类只应有一个权责，即单一权责原则(SRP)。当然也因此可以限制一个类的长度。 内聚，内聚性高，意味着类中的方法和变量互相依赖、互相结合成一个逻辑整体。 依赖倒置原则（DIP）。dip认为类应当依赖于抽象而不是依赖于具体细节。 遵循以下规则，设计就能变得简单： 运行所有测试 不可重复 表达了程序员的意图 尽可能的减少类和方法的数量 以上规则按其重要程度排列 在重构过程中，可以应用有关优秀软件设计的一切知识，提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，这也是应用简单设计后三条规则的地方：消除重复，保证表达力，尽可能减少类和方法的数量。 通常倾向于选用非静态的方法，如果确实需要静态函数，确保该函数永远不需要有多态的行为。 让程序可读的最有力方法之一就是将计算过程打算成有意义的单词命名的变量，当然，这个还是需要一个度，也不能完全拆分成很多变量，这样会造成代码冗余。 函数名称应该表达其行为。也就是说，调用一个函数，看函数名称就可以让人知道该函数做了什么事情。 逻辑依赖改为函数依赖。一个函数的使用，不应该对调用者有假定条件(即逻辑依赖)。 用命名常量代替魔术数。 代码中应当消除含糊不定和不准确的写法。 封装条件；避免否定式的条件，因为否定式的条件总是会比肯定式的难以理解一些。 函数只应该做一件事，即函数的原子性。 代码结构应当始终一致，不能随意设定和编写。 避免传递浏览or传递调用，即a.getB().getC().dosomething();这种方法，按道理来说，a与b协作，b与c协作，那么a跟c不应当有直接调用。 不要继承常量。]]></content>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F05%2F08%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
